from __future__ import annotations

import json
import re
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from .report_parser import normalize_cyrillic_ve, parse_report


@dataclass
class CorrectionResult:
    corrected_report: str
    applied: List[str]


def _ensure_marker(text: str, marker: str) -> str:
    if marker in text:
        return text
    return f"{marker}\n{text}" if marker.endswith("START ###") else f"{text}\n{marker}"


def _ensure_report_envelope(text: str) -> str:
    if "VIDEO_ANALYSIS_REPORT_START" not in text:
        text = f"### VIDEO_ANALYSIS_REPORT_START ###\n{text.strip()}"
    if "VIDEO_ANALYSIS_REPORT_END" not in text:
        text = f"{text.strip()}\n### VIDEO_ANALYSIS_REPORT_END ###"
    return text


def _insert_section_if_missing(text: str, heading: str, content: str, before: Optional[str] = None) -> str:
    pattern = re.compile(rf"###\s*{re.escape(heading)}\s*###", re.IGNORECASE)
    if pattern.search(text):
        return text
    block = f"\n### {heading} ###\n{content.strip()}\n"
    if before:
        idx = text.lower().find(before.lower())
        if idx != -1:
            return text[:idx] + block + text[idx:]
    return text + block


def build_minimal_aggregation_block(video_id: str, mode: str, indices: Dict[str, Any], used_ids: Dict[str, List[str]]) -> str:
    payload = {
        "video_id": video_id,
        "analysis_mode": mode,
        "indices": indices,
        "entities_used": used_ids,
    }
    return "```json\n" + json.dumps(payload, ensure_ascii=False, indent=2) + "\n```"


def auto_correct_report(
    *,
    raw_report: str,
    video_id: str,
    mode: str,
    indices: Dict[str, Any],
    used_ids: Dict[str, List[str]],
) -> CorrectionResult:
    """Apply safe corrections that do not change semantic meaning.

    We keep corrections conservative:
    - Fix Cyrillic 'В' in 'КОММЕНТАРИЕВ'
    - Ensure START/END markers are present
    - Ensure presence of mandatory headings (with placeholders if needed)
    - Ensure 'ДАННЫЕ ДЛЯ АГРЕГАЦИИ' contains a JSON block
    """
    applied: List[str] = []
    text = normalize_cyrillic_ve(raw_report).strip()

    # Report envelope
    before = text
    text = _ensure_report_envelope(text)
    if text != before:
        applied.append("added_report_start_end")

    # Metrics envelope (optional markers without ###)
    if "VIDEO_ANALYSIS_METRICS_START" not in text:
        # Insert right after report start
        text = re.sub(
            r"###\s*VIDEO_ANALYSIS_REPORT_START\s*###",
            "### VIDEO_ANALYSIS_REPORT_START ###\nVIDEO_ANALYSIS_METRICS_START",
            text,
            flags=re.IGNORECASE,
        )
        applied.append("added_metrics_start")
    if "VIDEO_ANALYSIS_METRICS_END" not in text:
        # Insert before report end
        text = re.sub(
            r"###\s*VIDEO_ANALYSIS_REPORT_END\s*###",
            "VIDEO_ANALYSIS_METRICS_END\n### VIDEO_ANALYSIS_REPORT_END ###",
            text,
            flags=re.IGNORECASE,
        )
        applied.append("added_metrics_end")

    # We only auto-insert the aggregation block because it can be derived safely.
    # Other sections contain semantic content and should be regenerated by the model.
    if re.search(r"###\s*ДАННЫЕ ДЛЯ АГРЕГАЦИИ\s*###", text, flags=re.IGNORECASE) is None:
        block = build_minimal_aggregation_block(video_id, mode, indices, used_ids)
        text = _insert_section_if_missing(text, "ДАННЫЕ ДЛЯ АГРЕГАЦИИ", block)
        applied.append("added_section:ДАННЫЕ ДЛЯ АГРЕГАЦИИ")

    # Ensure aggregation JSON exists
    parsed = parse_report(text)
    agg = parsed.headings.get("ДАННЫЕ ДЛЯ АГРЕГАЦИИ")
    if agg and "```json" not in agg.lower():
        block = build_minimal_aggregation_block(video_id, mode, indices, used_ids)
        # Replace section content completely to guarantee machine-readability
        text = re.sub(
            r"###\s*ДАННЫЕ ДЛЯ АГРЕГАЦИИ\s*###.*?(?=(?:\n###\s*|\nVIDEO_ANALYSIS_METRICS_END|\n###\s*VIDEO_ANALYSIS_REPORT_END))",
            f"### ДАННЫЕ ДЛЯ АГРЕГАЦИИ ###\n{block}\n",
            text,
            flags=re.IGNORECASE | re.DOTALL,
        )
        applied.append("normalized_aggregation_block")

    # Normalize analysis comments header typo: sometimes comes as 'АНАЛИЗ КОММЕНТАРИЕB'
    fixed = normalize_cyrillic_ve(text)
    if fixed != text:
        text = fixed
        applied.append("fixed_cyrillic_ve")

    return CorrectionResult(corrected_report=text, applied=applied)
